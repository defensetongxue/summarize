# implement for DGAT
## 朴素GAT
    
    cora: 87.2635, 1.13 
    cite: 76.3597, 1.24 
    cham: 55.3289, 2.35  
训练时长长 收敛慢，反复波动，往往需要训练800epoch以上。
## maxneibor:
    cora:168
    citeseer 99
    chameleon 88

| 实现方法                            | cora             | cite              | cham               |
| ----------------------------------- | ---------------- | ----------------- | ------------------ |
| **mode1**:neigborAtt(QKV)+GCN       | **83.4205, 1.4** | 72.4132, 1.5      | 71.7763, 2.54      |
| **mode2**:neigborAtt(GAT-impl)+GCN  | 82.2535, 1.87    | 72.2222, 1.82     | 69.8903, 2.3       |
| **mode3**:neigborAtt(QKV)+GAT(same) | 83.2193, 2.04    | **72.4410, 1.93** | **72.3903,  1.51** |
| **mode4**:neigborAtt(QKV)+GAT(diff) | 83.2997, 1.69    | 72.2824, 1.18     | 72.1271, 2.22      |
mode3和mode4的区别是neigborGAT和后续的GAT是不是用的同一套QKV参数

## 扩充节点策略
### NeigborAtt+GCN：**每个节点取得最近的10/20/50节点**
最近的定义：利用带重启的随机游走算法对每个节点进行计算权重，取权重最大的认为是最近的。
| 最近的k个节点 | cora             | cite             | cham              |
| ------------- | ---------------- | ---------------- | ----------------- |
| 0             | **83.4205, 1.4** | **72.4132, 1.5** | **71.7763, 2.54** |
| 10            | 84.3661, 0.84    | 72.1172, 1.36    | 34.5614, 2.62     |
| 20            | 83.4607, 1.04    | 70.5149, 1.68    | 32.5438, 2.47     |
| 50            | 83.7223, 1.31    | 67.9024, 3.18    | 31.7324, 2.01     |

特点: 所用时间少。

解释：对于chameleon数据的影响很大，是由于chameleon数据集很多类的数量本身就不多
### NeigborAtt+GCN 扩展：**2hop**
训练用时太长，难以跑完
cham：(52.85+62.06+58.33)=**57.74**
### NeigborAtt+GCN 对邻居少的采用2hop，其他采用1hop
   | 对于邻居节点少于 | cham              |
   | ---------------- | ----------------- |
   | 0                | **71.7763, 2.54** |
   | 5                | 69.8684, 2.52     |
   | 10               | 67.9825, 2.44     |
   | 20               | 61.4035, 2.83     |
 
### NeigborAtt+GAT **对邻居少的采用2hop，其他采用1hop**
| 对于邻居节点少于 | cham              |
| ---------------- | ----------------- |
| 0                | 72.1271, 2.22     |
| 2                | 71.5351, 1.63     |
| 3                | **72.6974, 1.89** |
| 4                | 72.3465, 2.01     |
| 5                | 71.6447, 2.13     |
| 10               | 68.7939, 2.15     |
| 20               | 64.9781, 1.88     |

### **deepwallk 和rwr 增补法**
利用每个向量进行deepwalk训练出的embeding向量点积，计算在结构上相似的点添加到点的邻居中。同时也考虑，每一个点经历过rwr后的向量。

**deepwalk更倾向表示在图新结构上的相似程度**

**rwr更倾向表示距离中心点的距离**

对低度数节点进行增补，当度数少于limits，**保留在deepwalk视角下最近的A个节点和在rwr视角最近的B个节点。**

| limits | A   | B   | 效果             |
| ------ | --- | --- | ---------------- |
| 0      | 0   | 0   | 72.1271, 2.22    |
| 4      | 4   | 4   | **72.4342, 1.7** |
| 4      | 0   | 10  | 70.5482, 3.14    |
| 4      | 10  | 0   | 71.9737, 1.64    |
| 4      | 10  | 0   | 69.2544, 1.27    |
| 4      | 10  | 0   | 65.4167, 2.28    |

然后我看看**对于GAT来说**，这种对低度数节点进行按照临近或图形结构增补分方法有没有效果。

考虑运行时间，只跑了5次切分的数据

| limits | A   | B   | cora              | cite              | cham              |
| ------ | --- | --- | ----------------- | ----------------- | ----------------- |
| 0      | 0   | 0   | **87.2635, 1.13** | **76.3597, 1.24** | 55.3289, 2.35     |
| 4      | 4   | 4   | 86.1971, 1.2      | 69.3627, 4.3      | **55.4385, 2.19** |
| 4      | 0   | 10  |                   |                   | 54.6052, 2.87     |
| 4      | 0   | 4   | 86.5593, 1.73     | 72.6059, 2.72     |
| 4      | 4   | 0   | 85.8752, 1.51     | 70.3579, 3.93     |                   |


# 实验探究：

## 假设：低度数节点更容易错判，所以加边有效 **错误**
实验指标：

    错误节点的平均度数，所有节点的平均度数=19.4753,16.8253

    错误节点中度数小于等于3的比例：正确……=0.1823, 0.1431

度数包括自身

**得到结论，在chameleon中节点度数低和效果差之间没有平均意义上的联系**
## 在deepwalk的排名中，随着排名的靠前，对应的边越可能是类内边 **正确**
X轴是考虑deepwalk排名前x的点（除自己以外）

Y轴是类内边占据的比例

**baseLine 直接邻居中类内边的比例为0.245左右**
![](/data/5.00201.png)
![](/data/5.002.png)


**得到结论，在chameleon中deepwalk的排名靠前和可能是类内边**

## 在rwr的排名中，随着排名的靠前，对应的边越可能是类内边
X轴是考虑rwr排名前x的点（除自己以外）

Y轴是类内边占据的比例

绿色表示在错误点集中

红色表示所有点集中
![](/data/5.rwrrank.png)

**得到结论，在chameleon中rwr的排名靠前和此邻居是类内边没有显著关系，所以2hop可能得不到很好的结果**
## 研究：节点邻居类内边的比例
X轴考虑nhop的邻居

Y轴是类外边占据的比例


![](/data/5.006.png)
结论：GAT错误节点类外边占比高于我们的模型，说明我们正确处理了一部分的类外边比较高的节点

猜测：对于GAT来说，在错误节点中，类外边的比例应该高于全节点。说明GAT不能处理直接的类外边多的情况。
<!-- 
## 对2hop性能下降的解释
X轴考虑nhop的邻居

Y轴的定义：考虑khop的邻居，如果在这些邻居中，同类邻居占比最高，则说明这个点比较好。Y表示错误点集合里面这样的好的点的比例。如果Y高，说明在错误点集合中很多好的点被错误的分类了。所以不好。
![](005.png) 
 -->
## 采用deepwalk的邻居
| neigbor | acc(run 5 times) |
| ------- | ---------------- |
| 10      | 62.4561          |
| 20      | 62.2368          |
| 30      | 62.9386          |
| 40      | 61.8421          |
| 50      | 62.1053          |
| 100     | 60.3947          |

label的数目
[456, 460, 453, 521, 387]
# 目前存疑的点
1. neigborAtt加GAT|GCN为什么在效果上差不多
2. 还有没有可能有更好的加边的方法
# 可以改进的地方
1. 更改实现方法
2. 优化加边的方案

1. prime att impl new W a 
2. q k , wq wk W a
3. GCN 
4. 验证 FSGNN 去hop  
5. feature pre process
6. norm 
7. Brit 
8. lr normforA dropedge 附录 hidden mlp_layer